% Chapter Template

\chapter{Implementation} % Main chapter title

\label{Chapter4} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Chapter 4. \emph{Implementation}} % Change X to a consecutive number; this is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Introduction}

This chapter describes the implementation of an experiment undertaken to answer the research question proposed by this thesis. A critical first step in performing that experiment is the implementation of a defeasible reasoning system. This is taken as a starting point for this chapter. 

The application architecture and programming decisions that were made are explained and justified with respect to how they support the experiment. The challenges associated with implementing a system of this nature are presented along with the solutions pursued to overcome those challenges.

The implementation of the experiment is then discussed. Specific details of how events unfolded are mentioned where they are relevant to discussion in the evaluation section.

\section{Defeasible Reasoning Software Implementation}

The research question of this dissertation deals specifically with an implementation of defeasible reasoning. The design of the system was outlined in chapter ~\ref{Chapter3} without any specific implementation details discussed. 

It was decided to implement the software as a web application. In the last 10 years web browser technology has improved vastly. Advances such as HTML5 APIs, powerful Javascript engines and mobile technology allows fully featured applications to be developed and run in the browser. 

Developing the application as a web based one offers a number of practical advantages to the experiment. Participants in the experiment can access the application remotely from anywhere. The software is platform independent and can run on any web browser with Javascript enabled. No software needs to be installed on different machines. No software needs to be updated locally, just once on the application server. All of the data associated with the DR experiment is all located and stored on the server allowing it to be retrieved easily for analysis.

%-----------------------------------
%	SYSTEM ARCHITECTURE
%-----------------------------------
\subsection{System Architecture}

In chapter~\ref{Chapter3} the required system functionality was designed and relevant components identified. The functionality of eliciting the knowledge base (the AF and membership functions) and the verification of this knowledge base is implemented as a Javascript client application. This communicates with a back-end server that provides a RESTful Web service written in PHP (using the Slim Framework\footnote{\url{www.slimframework.com}}).

The Web Service back-end provides the basic functions outlined for the application. The back-end saves a knowledge base to disk as a JSON file. The Javascript client can request a  list of knowledge bases and from this list retrieve a knowledge base previously created by the user. Knowledge bases were saved as JSON files on disk rather than in a database. This allowed structure of the application to change more fluently during development. It also supports knowledge bases to be examined and serialized in their complete form without needing to assemble it with queries from the database. The server allows the client to access data stored as CSV files so that an expert can evaluate their knowledge base against the data. 
The last critical component of the server application is to take a row from the data set and compute the value of the construct using the knowledge-base.

The application is served from an apache server running on a virualised Ubuntu instance provided by the Okeanos project \footnote{\url{okeanos-global.grnet.gr}}.

In order to speed up the development process a number of open source frameworks and libraries have been utilised in the software implementation. The CSS framework Bootstrap\footnote{\url{getbootstrap.com}} and the Javascript library JQuery\footnote{\url{jquery.com}} have been used for presentational aspects of the site. Bootstrap provides a number of useful components such as modal boxes tjat allow the software to present information to the user in a clear manner. JQuery provides wrappers arround native browser functionality such as DOM manipulation and AJAX networking facilities that abstract away the inconsistencies between browser implementations.

The graphical input of argumentation frameworks and membership functions is achieved using the  D3 library\footnote{\url{d3js.org}} developed by Bostock et al.\cite{2011-d3} D3.js is a data visualisation library that allows developers and designers to interact with data in the browser. Data can be loaded from urls in multiple formats such as JSON and CSV. Data points can be ``attached'' to DOM elements which provides useful functions. The styling of the DOM element can be linked to the value of the data and the data can be manipulated by user interactions. D3 is most commonly used with SVG\footnote{\url{www.w3.org/Graphics/SVG/}} (Scalable Vector Graphics) a markup language for implementing vector graphics. SVG has been an open standard for more than 10 years now, as a result it has been widely implemented and there is currently more support for it than other graphics alternatives such as HTML5 Canvas. Two key features of D3 that are used in the implementation of the experiment software are it's implementation of Bezier curves and it's force directed graph implementation.

The server implementation requires Argumentation semantics to be computed based on the input of a Dung Argumentation Framework. Computing these semantics efficiently requires a deep understanding of argumentation theory, graph theory and algorithms. An efficient implementation of these algorithms has been made available by the University of Dundee under the Apache License, Version 2.0. The Dung-o-matic\footnote{\url{www.arg-tech.org/index.php/projects/dung-o-matic/}} is an efficient Java implementation of a Dung argumentation framework. 

The technologies outlined in this section are manifested in the application architecture in figure~\ref{fig:AppArch}. With these underlying technologies established a number of implementation challenges remain. The solutions to these challenges are the focus of the following chapters.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{apparchitecture}
    \caption{Application Architecture}
    \label{fig:AppArch}
\end{figure}

%-----------------------------------
%	SYSTEM ARCHITECTURE
%-----------------------------------
\subsection{Application Front End}

The two crucial features of the application front-end are the interface for drawing argumentation frameworks and the interface for drawing membership functions. The implementation of these features is discussed here.

The implementation leverages D3's force-directed layout\footnote{\url{https://github.com/mbostock/d3/wiki/Force-Layout}}, a built in layout that solves the problems posed when visualising graph data structures. Typical data visualisation techniques take values and parse them one by one, drawing a marker in a position based on each value. This is not the case with graph data structures. With graph data structures, it is generally preferable to have vertices that have common edges close together and to have those without common edges far apart. D3's force directed layout takes list of vertices and edges and generates positions for vertices using simulation inspired by physics. Similarly to sub-atomic particles, nodes are given charges that repel other nodes in the graph and are kept from drifting apart by the links in the graph. There is also a force at the center of the visualisation that prevents any of the nodes from drifting outside the view port. 

By utilising this layout and D3's event helpers (listeners for mouse actions such as click and drag) an interface can be implemented that allows a user to input a directed graph, or in the case of the experiment, an argumentation framework. The user can create a node by clicking on an empty space on the graph and can create links between two nodes by dragging from one node to another. When the user creates a node they are prompted to give the node a label. This results in a knowledge base being represented as in listing~\ref{lst:kbds}.


\begin{lstlisting}[caption={JSON data structure for argumentation framework},label={lst:kbds}]
knowledge_base {
  nodes : [
    {
      id: 0
    },
    {
      id: 1
    },
    {
      id: 2
    }
  ],
    lastNodeId : 2,
    links : [
      {source: nodes[0], target: nodes[1], left: false, right: true },
      {source: nodes[1], target: nodes[2], left: false, right: true }
  ]
}
\end{lstlisting}

D3 expects the data as an array of node objects and an array of links which contain references to the nodes. It adds x and y values to the nodes to track their position in the viewport and updates theses values at a fixed interval in order to animate the graph. The id of the last node added to the viewport is stored in the lastNodeId variable. This is important for creating new nodes as nodes are tracked based on their IDs, not their array indexes. 

Three types of attack relation must be modeled by the interface for correct implementation of the system. These attacks are undercutting attacks, rebutting attacks and mitigating arguments. Undercutting attacks are implemented simply as an arrow from the attacking node to the attacked node. In the data structure this is modeled as a link with the value for either `right' or `left' equal to true. In a rebuttal attack both arguments attack each other. This link is visualised as an arrow with two ends. In the data structure this is represented by setting both `right' and `left' equal to true. Examples of these arguments visualised using the tool are shown in figure~\ref{fig:undercutting} and figure~\ref{fig:rebuttal}. Mitigating arguments are modeled the same as undercutting arguments but are represented in the system by labeling their output functions as ``mitigating arguments''.

\begin{figure}
\subfloat[An undercutting attack\label{fig:undercutting}]
  {\includegraphics[width=.49\linewidth]{undercutting}}\hfill
\subfloat[A rebuttal attack\label{fig:rebuttal}]
  {\includegraphics[width=.49\linewidth]{rebuttal}}\hfill
\caption{Examples of different attacks drawn using the interface}
\end{figure}

By selecting a node in the graph a user can then define membership functions representing the internal premises of the argument and an output function representing the contribution of the truth of this argument to the overall value of the construct. It was decided in the system design phase that the user should be able to draw these functions using the interface. It was decided to utilise Bezier curves to achieve this in a manner that is simple to implement, usable and that would facitiate easy representation, storage and serialisation of membership functions. 

According to \cite{farin2002handbook}, Bezier curves provide a ``geometric-based method for describing and manipulating polynomial curves and surfaces.'' Bezier curves are parametric curves in which each point on the curve is a function of the parameter \textit{t}. Bezier curves are defined by a number of control point that they interpolate. The curves begin at their first control point x(0) and end at their last control point x(1).

Bezier curves may be defined recursively is draw on for their implementation in the system. Given a Bezier curve $\mathbf{B}_{\mathbf{P}_0\mathbf{P}_1\ldots\mathbf{P}_n}$ with points $\mathbf{P}_0\mathbf{P}_1\ldots\mathbf{P}_n$ the recursive definition of a curve is:

\begin{equation}
\label{math:recursivedef}

\mathbf{B}(t) = \mathbf{B}_{\mathbf{P}_0\mathbf{P}_1\ldots\mathbf{P}_n}(t)
= (1-t)\mathbf{B}_{\mathbf{P}_0\mathbf{P}_1\ldots\mathbf{P}_{n-1}}(t) + t\mathbf{B}_{\mathbf{P}_1\mathbf{P}_2\ldots\mathbf{P}_n}(t)

\end{equation}

where $\mathbf{B}_{\mathbf{P}_0}(t) = \mathbf{P}_0}$ and $\mathbf{B}_{\mathbf{P}_n}(t) = \mathbf{P}_n}$.

D3 provides methods for manipulating SVG, which defines it's `paths' (Bezier curves) using control points. By providing the user with a collection of control point the can drag it is possible for them to define curves however they please. It also provides the advantage of allowing membership functions and output functions to be  defined simply as control points in the data model. As bezier curves exist within the range 0 and 1 on the x and y axis the associated values must be scaled to the users desires. Users can input minimum and maximum values that are used to scale the graph. These are stored with the membership function in the JSON data structure for later processing. From this a single argument can be defined in JSON as in listing~\ref{lst:arg_memfunc}. In order to allow users to create membership functions quickly functionality was implemented to allow the user to save previously used functions as template functions as can be seen in figure~\ref{fig:membfunc}.

\begin{figure}[!h]
\label{fig:membfunc}
\centering
\includegraphics[width=1\textwidth]{membershipfunction}
\caption{An interface that allows a user to `draw' a membership function using Bezier curves}
\end{figure}


\begin{lstlisting}[caption={JSON data structure a node including it's fuzzy membership functions},label={lst:arg_memfunc}]
    {
      id: 0,
      "name": "MD1",
      membership_functions: [{
      title: "Low Effort->Low MWL",
      points: [{x: 1, y: 25}, {x: 0, y: 0}, {x: 10, y: 0}, 
                {x: 20, y: 25}, {x: 22, y: 12}],
      xLabel: "X Label",
      yLabel: "Y Label",
      xMin: 0,
      xMax: 50,
      yMin: 0,
      yMax: 50,
    },
    {
      title: "Low Performance->High MWL",
      points: [{x: 10, y: 140}, {x: 30, y: 0}, {x: 140, y: 0},
                {x: 200, y: 150}, {x: 125, y: 125}],
      xLabel: "X Label",
      yLabel: "Y Label",
      xMin: 0,
      xMax: 250,
      yMin: 0,
      yMax: 300,
    }
    ],
    "output_function": {
        "title": "Underload",
        "xLabel": "Degree of Truth",
        "yLabel": "Y Label",
        "xMin": 0,
        "xMax": 1,
        "yMin": 0,
        "yMax": 33,
        "points": [
          {"x": 0.00454,"y": 33},{"x": 0.222,"y": 24.849},
          {"x": 0.46136,"y": 16.954},{"x": 0.65681,"y": 10.3458},{"x": 1,"y": 0}]
      },
    }
\end{lstlisting}

There is a flaw in this approach that should be noted. In order to compute the users beliefs accurately the membership function should follow the strict mathematical definition of a function; that it should only output a single value for any input. Bezier curves do not obey this rule as they are parametrised by \textit{t} and as a result it is possible for users to draw functions like in figure~\ref{fig:badness}. It is also possible for users to define functions with no corresponding output for a given figure. If a user does the system will compute an incorrect value for the premise and the result will be compromised. Participants in the experiment are made aware of this before undertaking the experiment.

\begin{figure}[h]
\label{fig:badness}
  {\includegraphics[width=.3\linewidth]{badness1}}\hfill
  {\includegraphics[width=.3\linewidth]{badness2}}\hfill
  {\includegraphics[width=.3\linewidth]{badness3}}\hfill
\caption{Examples of Bezier curves that can be drawn that are not functions}
\end{figure}

With the argumentation framework and membership function finally implemented the web interface appears as in figure~\ref{fig:finalUI}.

\begin{figure}[!h]
\label{fig:finalUI}
\centering
\includegraphics[width=1\textwidth]{Fullscreen}
\caption{The fully developed tool for eliciting knowledge bases}
\end{figure}

Once a knowledge base has been elicited from a user they can test their with the system by computing results. They can download a sample data set which is displayed as in figure~\cite{fig:sampleData}.

\begin{figure}[!h]
\label{fig:sampleData}
\centering
\includegraphics[width=1\textwidth]{data}
\caption{A selection of data for the user to test their knowledge base with}
\end{figure}

For a single row in the data the user can choose from a selection of semantics to run on the data (see figure~\cite{fig:semantics}).

\begin{figure}[!h]
\label{fig:semantics}
\centering
\includegraphics[width=1\textwidth]{options}
\caption{A list of options for semantics that can be computed by the system}
\end{figure}

The results of running the semantics are then presented to the user in the form given in figure~\cite{fig:semantics_results}. The results present an overall value for the construct as well as the total degree of truth of the semantic. Each argument that contribute to the semantic is returned as well as a degree of truth value and the value of the construct computed for that value. This extra information allows the user to scrutinise their knowledge base further.

\begin{figure}[!h]
\label{fig:semantics_results}
\centering
\includegraphics[width=1\textwidth]{results}
\caption{Results of computing the semantics on the framework. (Undefined values belong to mitigating arguments)}
\end{figure}



\subsection{Backend Implementation}

The basic functions of the backend such as storage and retrieval of data have been explained in section 1 of this chapter. The most crucial function of the back end is to take a row in the dataset and determine what a value for the construct associated with that row based on the knowledge base. In order to do this the javascript client makes a HTTP Post request to the base URL of the backend. This post request contains a JSON object which includes the expert's knowledge base, the row in the dataset and a list of semantics that are to be computed.

Once this request is parsed by the backend, irrelevant arguments and their associated links are removed from the graph. This is achieved by looking at an arguments membership functions. If the row in the dataset doesn't have a value between the minimum and maximum value of all premises in the argument then this argument is not activated and can be removed.

\begin{algorithm}
\caption{Determine activated arguments}
\begin{algorithmic} 
\FOR{each argument $arg$ \Pisymbol $N$ }
    % \FOR{each membership function $prem$ \Pisymbol{psy}{206} $arg$}
    %     $Val$ \leftarrow the column in the data corresponding to the premise
    %     \IF{$Val$ < $prem$\rightarrow$min$ OR $Val$ > $prem$\rightarrow$max$}
    %         Remove($arg$)
    %     \ENDIF
    % \ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}

The sub-graph of activated arguments and their relationships produced by this step is then formatted and passed into a Java program that computes the semantics. The Dung-o-matic is wrapped in a main function that takes three command line arguments: an array of nodes, and array of links between nodes and a list of semantics to be computed. This program has been exported as a JAR file which is then called from PHP using the \lstinline{exec()} function. The Java code returns JSON object with the semantic names as keys and the sub-graphs as an array of arrays associated with those keys.

Once the semantics have been computed for an Argumentation Framework the values associated with each argument can be computed. For a given row in the data set, the results for an argument remain the same no mater what the configuration of the framework is. This allows us to cache the output value of an argument in memory rather than having to recompute the same values for each semantic. The results are computed on the server using a bBzier curve implementation.

If the output function of an argument is labeled as a mitigating argument then that argument is ignored.

%scaling of bezier curves

For a given membership function with fixed values for it's control points any point on the curve can be described by a value t between 0 and 1. By passing t into the function we obtain a value for x and y. As it is not possible to simply pass in an x value and obtain a corresponding y value we must search for y by varying the parameter t. This is done efficiently using a binary search algorithm. For each iteration we pass in two values of t to get two values of x and compare them with our target x value. We continue to search a space closer and smaller to x until we arrive at a value that is within a threshold we consider to be satisfactory. The value of t at this point gives the y value.

This calculation is performed for each membership function in the node and an average of the values of the output is produced. This corresponds to the overall degree of truth for the argument. This value is then used as the input to the output function which computes an overall construct value for that argument. 

Once the all of the construct values and degrees of truth are taken the averages of both values are taken. These are considered to be the Degree of Truth of that semantic and the construct value for that semantic. This is returned along with a list of the arguments for that semantic to the client. The client presents this to the user so that the user can evaluate whether or not their knowledge base is behaving in a manner that they expect it to or not.

% Semantic algorithms

%-----------------------------------
%	EXPERIMENT IMPLEMENTATION
%-----------------------------------
\section{Experiment Implementation}

The software implemented as above was used by both an expert in mental work load and a lay person. Both were asked to describe their knowledge of mental workload as a defeasible knowledge base and the knowledge bases were collected on the server.

As computing the semantics for an AF is an NP complete problem it is not yet possible to compute the results for a whole data set in the time that it would take to complete a typical HTTP request-response cycle. For the purposes of the experiment the functionality to compute the results for a whole data set using a given knowledge base was wrapped in a command line tool written in PHP. In order to reduce the time taken to compute the results and so as to focus the analysis of the experiment only the grounded and preferred extensions were computed. These overall degree of truth for the semantic and the value of MWL for the row in the dataset were stored for later analysis.

%-----------------------------------
%	SUBSECTION 1
%-----------------------------------
\subsection{Weka}



%-----------------------------------
%	SUBSECTION 2
%-----------------------------------

\subsection{Knowledge Base Elicitation}





\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{ExpertAF}
\caption{The Argumentation Framework developed by the expert using the tool}
\end{figure}





%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\subsection{Program Validation}

\subsection{Generation of Results}



\section{Conclusions}


